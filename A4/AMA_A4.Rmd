---
title: "Estimating the conditional variance by local linear regression"
author: "Caballero Verg√©s Biel, Menzenbach Svenja and Reyes Illescas Kleber Enrique"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r loading libraries, include=FALSE}
library(sm)
```

```{r loading data, include=FALSE}
data(aircraft)
help(aircraft)
attach(aircraft)
lgPower <- log(Power)
lgSpan <- log(Span)
lgLength <- log(Length)
lgWeight <- log(Weight)
lgSpeed <- log(Speed)
lgRange <- log(Range)
```

# Estimating the conditional variance

## 1.Fit a nonparametric regression to data $(x_i, y_i)$ and save the estimated values $\hat{m}(x_i)$.
```{r question 1, echo=FALSE}
source("locpolreg.R")
x <- Yr
y <- lgWeight

fit.loc_pol_reg <- function(x, y){
  out.cv <- h.cv.gcv(x=x, y=y)$cv # this function uses locpolreg
  h_opt <- which.min(out.cv)
  return <- locpolreg(x=x,y=y,h=h_opt,doing.plot=TRUE)
}

fit_y <- fit.loc_pol_reg(x, y)
mtgr <- fit_y$mtgr


```

## 2.Transform the estimated residuals $\hat{\epsilon} = y_i - \hat{m}(x_i)$
\[
z_i = \log \epsilon_i^2 = log((y_i - \hat{x_i}))^2)
\] 
```{r question 2, echo=FALSE}
z <- log((y - mtgr)^2)
```

## 3. Fit a nonparametric regression to data $(x_i, z_i)$ and call the estimated function $\hat{q}(x)$. Observe that $\hat{q}(x)$ is an estimate of log $\sigma^2(x)$.
```{r question 3, echo=FALSE}
fit_z <- fit.loc_pol_reg(x, z)
q <- fit_z$mtgr
```

## 4. Estimate $\sigma^2(x)$ by 
\[
\hat{\sigma}^2(x) = e^{\hat{q}(x)}
\]
```{r question 4, echo=FALSE}
sig.sqr <- exp(q)
```

## plots
```{r}
plot(x, (y - mtgr)^2)
lines(x, sig.sqr, col="blue")


plot(x,mtgr, type = 'l')
lines(x,mtgr + 1.96 * sqrt(sig.sqr), col="blue")
lines(x,mtgr - 1.96 * sqrt(sig.sqr), col="blue")
```



## Ordinary and Generalized Cross-Validation
```{r}
h.cv.gcv <- function(x,y,h.v = exp(seq(log(diff(range(x))/20),
                                       log(diff(range(x))/4),l=10)), 
                     p=1,type.kernel="normal"){
  n <- length(x)
  cv <- h.v*0
  gcv <- h.v*0
  for (i in (1:length(h.v))){
    h <- h.v[i]
    aux <- locpolreg(x=x,y=y,h=h,p=p,tg=x,
                     type.kernel=type.kernel, doing.plot=FALSE)
    S <- aux$S
    h.y <- aux$mtgr
    hii <- diag(S)
    av.hii <- mean(hii)
    cv[i] <- sum(((y-h.y)/(1-hii))^2)/n
    gcv[i] <- sum(((y-h.y)/(1-av.hii))^2)/n
  }
  return(list(h.v=h.v,cv=cv,gcv=gcv))
}
```

